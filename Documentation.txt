lab4 part1 Documentation

Author: Hongyi Zhang <hongyiz@andrew.cmu.edu>
		Hailei Yu <haileiy@andrew.cmu.edu>
Date:   Nov. 24th, 2014


1. Introduction:
	In this lab, we developed a real-time embedded system kernel - Gravelv2. 
	Gravelv2 is a multi-task preemptive kernel developed based on the single-task kernel
	Gravelv1. Apart from io syscalls(implmented using SWI), time syscalls
	(implemented using IRQ timer), Gravelv2 provided the following functions to users:

	1.1: creating and running multiple tasks: users can create multiple tasks and the 
	kernel will assign priorities to tasks based on RMS. Then the kernel will run those 
	tasks according to their priorities preemptively.

	1.2: event_wait: In each user task, user can call event_wait to sleep and hook up 
	the task to a certain device to wait for the event(each device will trigger its 
	event periodically) when the task finishes its periodical job.

	1.3: mutex: Gravelv2 provides mutex locks to users to enable them to protect their 
	critical sections in their code.

2. Interface 
	Gravelv2 provides the following swi interfaces to users:
		io APIs: including read, write functions implemented in lab2, nothing changes 
				 except that we enabled IRQ interrupt which is disabled when entering 
				 swi_handler.

		time APIs: including time, sleep functions implemented in lab3, nothing changes 
				 here except that we enabled IRQ interrupt which is disabled when 
				 entering swi_handler.

		task_create: user can use this function to create multiple tasks(max number is 
				 63), gravelv2 will clear all the running tasks, and then assign 
				 different priorities to each task based on RMS(task with short T will 
				 get a higher priority) and allocate a tcb in sys_tcb to each task with 
				 launch_task as a wrapper and make all created tasks runnable in 
				 run_queue. Then Gravelv2 will call dispatch_nosave to launch the new 
				 task with the highest priority without saving the context of the current
				 task, in another word, Gravelv2 kills the task which calls 
				 create_task(). 

		event_wait: user can call event_wait to sleep and hook up the task to a certain
		 		 device to wait for the event(each device will trigger its event 
		 		 periodically) when the task finishes its periodical job.

		invalid_syscall: An invalid syscall causes the kernel to exit.

		mutex APIs: users can use mutex APIs to create mutex, lock and unlock. The 	
				 details of mutex implementation will be covered in mutex section.

3. TCBs and stacks 
	system_tcb supports 64 tcb blocks and since we allocate the last tcb block(
	system_tcb[63]) to idle task, we can support at most 63 user tasks.
	As for stacks, each tcb's user stack is defined by the user when user creating the 
	task; each tcb's kernel stack is allocated in thier tcb(kstack).

4. SWIs and IRQs
	When an irq occurs, irq wrapper(int_asm) will switch to svc_mode with spsr staying 
	the same as when entering irq mode. And before irq_wrapper switch to C_IRQ_Handler, 
	irq_wrapper pushed user_lr, user_sp and spsr into the current task's svc stack, and 
	pop them back when returning from C_IRQ_Handler. IRQ_wrapper is doing this in order 
	to make sure that if dispatch_nosave occurs in C_IRQ_Handler, when afterwards this 
	task is switched back, the execution routine will definitely be the same as if no 
	context_switch occured.
	For the same reason, we need to do the same thing in our S_SWI_Handler. 
	Since in lab2 and lab3 we have already made sure that S_SWI_Handler will
	maintain spsr, in our S_SWI_Handler we just need to make sure that before entering
	C_SWI_Handler we need to save the user_lr and user_sp in the current task's stack 
	and make sure that they pop back when returning from C_SWI_Handler.
	Besides, S_SWI_Handler need to disable IRQ interrupt when entering, and any syscall 
	which needs to enable IRQ will enable IRQ by themselves.
5. Context Switcher
	context switcher will save the current r4 - r11, lr, svc_sp to the context struct in 
	tcb, and then restores the target tcb's r4 - r11, lr, svc_sp to the corresponding 
	registers. Context Switcher can make sure that execution routine afterwards will be 
	the same as no context_switch has occured (as long as we can make sure user_lr, 
	user_sp and spsr is saved and restore properly).
	It should be noted that when a new task is created, instead of directly save values 
	to corresponding registers in context struct, we used task_launch function as a 
	wrapper. We save register values according to task_launch's specification, and 
	assign task_launch's entry address context.lr's value to make sure that the first 
	time this task is launched it will switch to launch_task with appropriate register 
	values.
				 
6. Schedule
	Gravelv2's scheduling is based on RMS. Each time user creates multiple tasks, 
	Gravelv2 will sort the tasks based on their T values, and assign the task with lower
	T a higher priority.

7. Dispatcher
	Each time when the kernel needs to switch from one task to another task, it will 
	call dispatcher to do the work. There are three kinds of dispatcher: 
		1): dispatch_nosave: This dispatcher is used when switching from a task calling 
		task_create. Dispatch_nosave will not save the current task's context and 
		directly switch to the task with the highest priority. This means that the 
		current task is killed.
		In addition, kernel will remove the target_task from runqueue, indicating that 
		this task is running.
		2): dispatch_save: This dispatcher is used when a task with higher priority is 
		waken up and the kernel will switch from the current task to the runnable task 
		with the highest priority. 
		It will add the current task into runqueue, and remove the target task out of 
		runqueue and then call ctx_switch_full to save the current task's context and 
		restore the target task's context.
		3): dispatch_sleep: This dispatcher is used when a task calls event_wait. this 
		dispatcher will attach the current task to the specified device and maintain the 
		current task out of runqueue to indicate that it is sleeping, and then it will 
		remove the runnable task with the highest priority from runqueue(unless it is an 
		idle task) and ctx_switch_full to this task.
8. Device
	when a task calls event_wait, Gravelv2 will attach the current task to the specified 
	device and make it sleep(using dev_wait).
	In C_IRQ_Handler, every time the irq interrupt occurs, it will call device_update. 
	device_update will examine if any device has reached its period, if so, kernel will 
	clear all the tasks hook up to this device and add all of them to the runqueue. Each 
	time after device update, C_IRQ_Handler will examine that whether the current 
	running task's priority is higher than the highest priority of the runnable tasks. 
	If not, kernel will call dispatch_save to switch to the runnable task with the 
	highest priority.
9. Mutex
	When a mutex lock is called, kernel will examine that whether the specified mutex is 
	holding by other tasks. If so, kernel will add the current task to the tail of the 
	sleep_queue of this mutex and then call dispatch_sleep to switch to other runnable 
	task and make current task sleep until unlock happens. If not, kernel will assign 
	the current task as this mutex's lock holder and return to the current task normally.
	
	When a mutex unlock is called, kernel will first remove the current task from the 
	mutex lock holder. Then kernel will check mutex's sleep queue. If the queue is 
	empty, kernel will just set the mutex as no task is holding it, else kernel will 
	remove the head of the sleep_queue as the lock holder and add it to the runqueue and 
	then kernel will check whehter the released task's priority is higher than the 
	current running task's priority. If so, kernel will call dispatch_save to switch to 
	the released task.













